<!DOCTYPE html>
<html lang="en">
<head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="">
    <meta property="og:title" content="PHP Code Coverage for your web/selenium automation">
    
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2017-03-31">
    
    <meta property="og:description" content="">
    <meta property="og:url" content="http://tarunlalwani.com/post/php-code-coverage-web-selenium/">
    <meta property="og:site_name" content="">
    
    <meta name="generator" content="Hugo 0.20.2" />
    <title>PHP Code Coverage for your web/selenium automation &middot; </title>
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">
    
    <link rel="stylesheet" href="http://tarunlalwani.comcss/style.css">
    
    <link href="http://tarunlalwani.com/index.xml" rel="alternate" type="application/rss+xml" title="" />
    
    

    
    
</head>
<body>

<nav class="navbar navbar-default navbar-fixed-top visible-xs">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
				<a class="navbar-brand" href="http://tarunlalwani.com"></a>
			
		</div>
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				
				
			</ul>
		</div>
	</div>
</nav>
<div class="container-fluid">
	<div class="row">
		<div id="menu" class="hidden-xs col-sm-4 col-md-3">
	<div id="menu-content" class="vertical-align">
		
			<h1 class="text-center"><a href="http://tarunlalwani.com"></a></h1>
		
		
		
		
		
		<div id="social" class="text-center">
			
			
			
			
			
		</div>
		<div id="links" class="text-center">
			
			
		</div>
	</div>
</div>

		<div id="content" class="col-xs-12 col-sm-8 col-md-9">
			<div class="row">
				<div id="post" class="col-sm-offset-1 col-sm-10 col-md-10 col-lg-8">

<main>
	<header>
		<h1>PHP Code Coverage for your web/selenium automation</h1>
	</header>

	<article>
		

<h1 id="approach-1">Approach 1</h1>

<p>PHP code coverage data can be collected using the <a href="https://github.com/sebastianbergmann/php-code-coverage">sebastianbergmann/php-code-coverage</a> composer module. But this is easier when we are running PHP unit test.</p>

<p>When we test our application using a browser, either through manual testing or through automation like Selenium or QTP. Every request get&rsquo;s generated by the Web Browser and is handled by a Web Server. This in many cases would be either Nginx or Apache.</p>

<p>It is important to know what level of code get&rsquo;s covered through the QA process. In PHP two approaches are used to serve client requests. First approach where every request gets forwarded to a single PHP file, and the file internally routes the request further. Frameworks like CodeIgniter, Wordpress, Laravel use the first approach. Second approach is where individual files directly serve the PHP request, this usually happens in custom PHP applications.</p>

<p>For us it was important to have code coverage as a configuration rather than a code change. So we needed a way to execute some code before every request.</p>

<h2 id="php-ini-configuration">php.ini configuration</h2>

<p>Digging into <code>php.ini</code> <a href="http://php.net/manual/en/ini.core.php#ini.auto-prepend-file">documentation</a> revelead two supported variables</p>

<ul>
<li><p><strong>auto_prepend_file</strong> <em>string</em> -
Specifies the name of a file that is automatically parsed before the main file. The file is included as if it was called with the require function, so include_path is used. The special value none disables auto-prepending.</p></li>

<li><p><strong>auto_append_file</strong> <em>string</em> -
Specifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used. The special value none disables auto-appending.</p></li>
</ul>

<h2 id="request-code-coverage-dumper">Request Code Coverage Dumper</h2>

<p>Now that we know the two variables <code>auto_prepend_file</code> and <code>auto_append_file</code>, we need a PHP code that gets appended at the start and dumps the code coverage at the end of the request.</p>

<p>My first approach was to use the <code>php-code-coverage</code> module to start coverage at every request and dump the coverage data at the end of the request.</p>

<h4 id="composer-json">composer.json</h4>

<pre><code class="language-json">{
	&quot;require&quot; : {
	&quot;phpunit/php-code-coverage&quot;:&quot;4.*&quot;	}
}
</code></pre>

<h4 id="var-www-codecoverage-start-php">/var/www/codecoverage/start.php</h4>

<pre><code class="language-php">&lt;?php
require_once &quot;vendor/autoload.php&quot;;
$current_dir = __DIR__;
$coverage = new SebastianBergmann\CodeCoverage\CodeCoverage;
$filter   = $coverage-&gt;filter();
$filter-&gt;addDirectoryToWhitelist(&quot;/var/www/html&quot;);


$test_name = (isset($_COOKIE['test_name']) &amp;&amp; !empty($_COOKIE['test_name'])) ? $_COOKIE['test_name'] : 'unknown_test_' . time();
$coverage-&gt;start($test_name);

function end_coverage()
{
    global $test_name;
    global $coverage;
    global $filter;
    global $current_dir;
    $coverageName = $current_dir . '/coverages/coverage-' . $test_name . '-' . microtime(true);
    
    try
    {
        $coverage-&gt;stop();
        $writer = new \SebastianBergmann\CodeCoverage\Report\Html\Facade; 
        $writer-&gt;process($coverage, $current_dir . '/report/');
        $writer = new SebastianBergmann\CodeCoverage\Report\PHP();
        $coverageName =  $current_dir .'/coverages/coverage-'. $test_name . '-' . microtime(true);
        $writer-&gt;process($coverage, $coverageName . '.php');
    }
    catch (Exception $ex)
    {
        file_put_contents($coverageName . '.ex', $ex);
    }
}

class coverage_dumper
{
	function __destruct()
	{
		end_coverage();
	}
}

$_coverage_dumper = new coverage_dumper();
</code></pre>

<p>The code above is self explainatory. But there are few points I would like to highlight.</p>

<h4 id="whitelist-and-blacklist">Whitelist and Blacklist</h4>

<pre><code class="language-php">$filter-&gt;addDirectoryToWhitelist(&quot;/var/www/html&quot;);
</code></pre>

<p>If you don&rsquo;t add any directory to white list, no code coverage would be generated. First add all the whitelist directories and then all the blacklist directories. If you are using composer in your project, then you would want to black list the vendor directory</p>

<h4 id="code-coverage-to-test-case-mapping">Code Coverage to Test Case mapping</h4>

<pre><code>$test_name = (isset($_COOKIE['test_name']) &amp;&amp; !empty($_COOKIE['test_name'])) ? $_COOKIE['test_name'] : 'unknown_test_' . time();
</code></pre>

<p>While dumping the code coverage, a test name can be associated with the same. This is important because a QA test case will have multiple request within the same test. Ability to map coverage to test cases would give more insights. To do so, you can set a cookie in the browser before starting the test case.</p>

<p>This can be done in multiple ways
* Create a dummy page which takes GET parameter and sets the cookie <code>test_name</code> with the given value
* Use Selenium API to add a cookie to the browser
* Use some other approach to pass the test_name, instead of the cookies. This would require update in <code>start.php</code></p>

<h2 id="enabling-the-code-coverage-collection">Enabling the code coverage collection</h2>

<p>There are multiple ways to enable code coverage. We will look at all the configuration</p>

<h5 id="1-using-php-ini">1. Using php.ini</h5>

<p>Edit /etc/php.ini and the below line to the same</p>

<pre><code class="language-php">  auto_prepend_file=/var/www/codecoverage/start.php
</code></pre>

<h5 id="2-codecoverage-ini">2. codecoverage.ini</h5>

<p>Second option is to create a <code>99-codecoverage.ini</code> in <code>/etc/php5/cli/conf.d</code> for PHP CLI or <code>/etc/php5/apache2/conf.d</code> for Apache Config</p>

<p>I wouldn&rsquo;t recommend Method #1 or #2 if you are only interested in capturing web request instead of CLI ones</p>

<h5 id="3-apache-htaccess">3. Apache .htaccess</h5>

<p>If you have a folder with <code>.htaccess</code> loading enabled, just add the below content to the file</p>

<pre><code>php_value auto_prepend_file &quot;/var/www/codecoverage/start.php&quot;
</code></pre>

<h5 id="4-apache-config">4. Apache config</h5>

<p>Create a <code>/etc/apache2/conf-available/codecoverage.conf</code> file with below content</p>

<pre><code>php_value auto_prepend_file &quot;/var/www/codecoverage/start.php&quot;
</code></pre>

<p>Enable the config using the <code>a2enconf</code> command</p>

<pre><code class="language-bash">$ sudo a2enconf codecoverage
$ sudo service apache2 reload
</code></pre>

<blockquote>
<p>Note: This can also be applied to any specific virtual host by updating the virtual host conf file</p>
</blockquote>

<h5 id="5-nginx-config">5. Nginx Config</h5>

<p>Nginx requests are usually forwarded to <code>php-fpm</code> and to pass <code>php_value</code> directive, we need to set a <code>fastcgi_param</code></p>

<pre><code>fastcgi_param PHP_VALUE &quot;auto_prepend_file=\&quot;/var/www/codecoverage/start.php&quot;&quot;;
</code></pre>

<blockquote>
<p>If you need to set multiple php values then look at <a href="https://coderwall.com/p/gt2g3q/setting-multiple-php_value-in-nginx-config">this</a> article for more details</p>
</blockquote>

<h4 id="sample-coverage-test-php">Sample coverage_test.php</h4>

<pre><code class="language-php">&lt;?php

function test_if_else($x, $y)
{
   if ($x == $y)
   {
     echo &quot;X and Y are equal&quot;;
   }
   else
   {
     echo &quot;X and Y are not equal&quot;;
   }
}

test_if_else(3, 4);
</code></pre>

<h2 id="generated-php-coverage-file">Generated PHP Coverage file</h2>

<p>When we run the coverage_test.php file through a browser, we get below coverage file generated</p>

<pre><code class="language-php">#coverage-unknown_test_1493209616-1493209616.4994.php
&lt;?php
$coverage = new SebastianBergmann\CodeCoverage\CodeCoverage;
$coverage-&gt;setData(array (
  '/var/www/html/test/coverage_test.php' =&gt;
  array (
    5 =&gt;
    array (
      0 =&gt; 'unknown_test_1493209616',
    ),
    6 =&gt;
    array (
      0 =&gt; 'unknown_test_1493209616',
    ),
    7 =&gt;
    array (
    ),
    8 =&gt;
    array (
    ),
    11 =&gt;
    array (
      0 =&gt; 'unknown_test_1493209616',
    ),
    13 =&gt;
    array (
      0 =&gt; 'unknown_test_1493209616',
    ),
    15 =&gt;
    array (
      0 =&gt; 'unknown_test_1493209616',
    ),
  ),
));
$coverage-&gt;setTests(array (
  'unknown_test_1493209616' =&gt;
  array (
    'size' =&gt; 'unknown',
    'status' =&gt; NULL,
  ),
));

$filter = $coverage-&gt;filter();
$filter-&gt;setWhitelistedFiles(array (
  '/var/www/html/test/coverage_test.php' =&gt; true,
));
</code></pre>

<h2 id="summary-report">Summary Report</h2>

<p>For every request a coverage php file will get generated in <code>/var/www/codecoverage/coverages/</code>. Now we need a way to combine these raw PHP reports and generate a HTML format report for the same</p>

<h4 id="combine-php">combine.php</h4>

<pre><code class="language-php">&lt;?php
    include_once(&quot;vendor/autoload.php&quot;);
    $coverages = glob(&quot;coverages/*.php&quot;);

    #increase the memory in multiples of 128M in case of memory error
    ini_set('memory_limit', '12800M');

    $final_coverage = new SebastianBergmann\CodeCoverage\CodeCoverage;
    $count = count($coverages);
    $i = 0;
    foreach ($coverages as $coverage_file)
    {
        $i++;
        echo &quot;Processing coverage ($i/$count) from $coverage_file&quot;. PHP_EOL;
        require_once($coverage_file);
        $final_coverage-&gt;merge($coverage);
    }

    #add the directories where source code files exists
    $final_coverage-&gt;filter()-&gt;addDirectoryToWhitelist(&quot;/var/www/html/&quot;);

    echo &quot;Generating final report...&quot; . PHP_EOL;
    $report = new \SebastianBergmann\CodeCoverage\Report\Html\Facade;
    $report-&gt;process($final_coverage,&quot;reports&quot;);
    echo &quot;Report generated succesfully&quot;. PHP_EOL;
?&gt;
</code></pre>

<p>Running the <code>php combine.php</code> command in <code>/var/www/codecoverage</code> will generate a summary report in <code>reports</code> folder. The summary report would look like below</p>

<div>
<img src="/images/code_coverage_summary.png" style="width: 100%;}" />
</div>

<h1 id="approach-2">Approach 2</h1>

<p>When I worked out Approach 1 and used with our automation suite on a large code base, it had a decent time cost. It increased request time by 2x-10x.</p>

<p>I was tasked to find a better approach. So I started digging into the <code>php-code-coverage</code> code and started debugging the whole solution to find pain points. My analysis results should 3 reasons which increased request time</p>

<ul>
<li>Directory whitelisting scans every file in directory</li>
<li>Each PHP file is scanned to find non-exectutable lines</li>
<li>During script termination the PHP report generation uses raw XDebug data and filters based on whitelist</li>
</ul>

<p>All these steps are reptitive. What i realized is that we could afford collecting raw Debug data instead of processed code coverage data. So created a simpler <code>start_xdebug.php</code></p>

<h4 id="var-www-codecoverage-start-xdebug-php">/var/www/codecoverage/start_xdebug.php</h4>

<pre><code class="language-php">&lt;?php
    $current_dir = __DIR__;
    $test_name = (isset($_COOKIE['test_name']) &amp;&amp; !empty($_COOKIE['test_name'])) ? $_COOKIE['test_name'] : 'unknown_test_' . time();
    xdebug_start_code_coverage(XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE);

    function end_coverage()
    {
        global $test_name;
        global $current_dir;
        $coverageName = $current_dir . '/coverages/coverage-' . $test_name . '-' . microtime(true);

        try {
            xdebug_stop_code_coverage(false);
            $coverageName = $current_dir . '/coverages/coverage-' . $test_name . '-' . microtime(true);
            $codecoverageData = json_encode(xdebug_get_code_coverage());
            file_put_contents($coverageName . '.json', $codecoverageData);
        } catch (Exception $ex) {
            file_put_contents($coverageName . '.ex', $ex);
        }
    }

    class coverage_dumper
    {
        function __destruct()
        {
            try {
                end_coverage();
            } catch (Exception $ex) {
                echo str($ex);
            }
        }
    }

    $_coverage_dumper = new coverage_dumper();
</code></pre>

<p>Instead of generating the PHP file this time, we generate the json file. If speed is a matter, one can even use serialize function and compare the performance difference while dumping the raw data.</p>

<p>Since now we are dumping <code>json</code> data instead of <code>php</code> files, our summary report generation code will also change</p>

<pre><code class="language-php">&lt;?php
    include_once(&quot;vendor/autoload.php&quot;);
    $coverages = glob(&quot;coverages/*.json&quot;);

    #increase the memory in multiples of 128M in case of memory error
    ini_set('memory_limit', '12800M');

    $final_coverage = new SebastianBergmann\CodeCoverage\CodeCoverage;
    $count = count($coverages);
    $i = 0;

    $final_coverage-&gt;filter()-&gt;addDirectoryToWhitelist(&quot;/var/www/html/&quot;);

    foreach ($coverages as $coverage_file)
    {
        $i++;
        echo &quot;Processing coverage ($i/$count) from $coverage_file&quot;. PHP_EOL;
        $codecoverageData = json_decode(file_get_contents($coverage_file), JSON_OBJECT_AS_ARRAY);
        $test_name = str_ireplace(basename($coverage_file,&quot;.json&quot;),&quot;coverage-&quot;, &quot;&quot;);
        $final_coverage-&gt;append($codecoverageData, $test_name);
    }

    echo &quot;Generating final report...&quot; . PHP_EOL;
    $report = new \SebastianBergmann\CodeCoverage\Report\Html\Facade;
    $report-&gt;process($final_coverage,&quot;reports&quot;);
    echo &quot;Report generated succesfully&quot;. PHP_EOL;
?&gt;
</code></pre>

<p>A import change here is moving the <code>addDirectoryToWhitelist</code> call before loading the data, else all coverages would be filtered out</p>

<p>From our observation Approach 2 is 1x-1.3x.</p>

<p>You can download the code for above from [tarunlalwani/php-code-coverage-web]()</p>

	</article>
</main>

<div id="bottom-nav" class="text-center center-block">
	<a href=" http://tarunlalwani.com" class="btn btn-default"><i class="fa fa-home"></i> Home</a>
</div>



						</div>
					</div>
				</div>
			</div>
		</div>
  </div>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.2/js/bootstrap.min.js"></script>
  
  
  <script src="http://tarunlalwani.com/js/App.js"></script>
  
</body>
</html>
